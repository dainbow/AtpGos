#import "../conf.typ": *

== Хэш-таблица, полиномиальная хэш-функция

#definition[
  Пусть $U$ -- множество рассматриваемых объектов, тогда $h : U -> {0, 1, ..., k - 1}$ называется *хэш-функцией*
]

#definition[
  Элементы $x, y in U, x != y$ образуют *коллизию*, если $h(x) = h(y)$
]

#definition[
  Заведём массив размера $k$ и скажем, что элемент $v$ есть в множестве, если по индексу $h(v)$ уже занята ячейка.

  Такая схема называется *прямой адресацией*.
]

#definition[
  *Бакетом* называют нечто, хранящее все элементы, образующие коллизию.
]

#note("Хэш-таблица на цепочках")[
  На практике, элементы, образующие коллизию, добавляются в бакет, например, список.

  Давайте посчитаем средний размер бакета:

  Считаем, что хэш-функция отображает из ${0, 1, ..., n - 1}$ в ${0, 1, ..., k - 1}$, а вероятность коллизиции равномерная:
  #eq[
    $P({h(x) = h(y)}) = cases(1\, x = y, 1 / k \, x != y)$
  ]

  Тогда для произвольного бакета, соответствующего некоторому элементу $q in {0, ..., n}$, матожидание его размера:
  #eq[
    $EE L_q = EE sum_(i = 1)^n II({h(q) = h(i)}) =\ P({h(q) = h(q)}) + sum_(i = 1, i != q)^n P({h(q) = h(i)}) = 1 + (n - 1) / k <= 1 + n / k$
  ]
]

#definition[
  *Коэффициентом загруженности* называют величину $alpha = n / k$.

  Заметим, что мы знаем эту величину уже при определении хэш-функции, а значит стоимость всех операций заведомо ограничивается некоторой константой, зависимой от $alpha$.
]

#note("Полиномиальное хеширование")[
  Приведём пример некоторой хэш-функции в отношении строк. Для строки $p$ размера $m$ такой хэш определён следующий образом:
  #eq[
    $h (p[1 : m]) = (sum_(i = 1)^m p[i] x^(i - 1)) mod q$
  ]
  где $q$ -- некоторое простое число, а $x$ -- число от $0$ до $q - 1$.
]
