#import "../conf.typ": *

== Минимальное остовное дерево: алгоритмы Прима и Крускала

#definition[
  $T subset G$ -- *остовное дерево*, если $T$ содержит все вершины $G$ и является деревом.
]

#definition[
  *Минимальным* остовным деревом во взвешенном неориентированном графе называется остовное дерево минимального веса.
]

#definition[
  $(S, T)$ -- *разрез* графа $(V, E)$, если $S union T = V and V sect T = emptyset$.
]

#definition[
  Ребро $(u, v)$ *пересекает разрез* $(S, T)$, если $u$ и $v$ -- в разных частях разреза.
]

#definition[
  Пусть $G' = (V, E')$ -- подграф некоторого минимального остовного дерева графа $G$.

  Ребро $(u, v) in.not G'$ называется безопасным, если при добавлении его в $G'$, $G' union {(u, v)}$ также является подграфом минимального остовного дерева графа $G$.
]

#theorem[
  Рассмотрим связный неориентированный взвешенный граф $G = (V, E)$ с весовой функцией $w : E -> RR$.

  Пусть $G' = (V, E')$ -- подграф некоторого минимального остовного дерева $G$, $(S, T)$ -- разрез $G$, такой, что ни одно ребро из $E'$ не пересекает разрез, а $(u, v)$ -- ребро минимального веса среди всех рёбер, пересекающих разрез $(S, T)$.

  Тогда ребро $e = (u, v)$ является безопасным для $G'$.
]

#proof[
  Достроим $E'$ до некоторого минимального остовного дерева, обозначим его $T_min$. Если ребро $e in T_min$, то лемма доказана, поэтому рассмотрим случай, когда ребро $e in.not T_min$.

  Рассмотрим пусть в $T_min$ от вершины $u$ до вершины $v$. Так как эти вершины принадлежат разным долям разреза, то хотя бы одно ребро на пути пересекает разрез, назовём его $e'$.

  По условию леммы, $w(e) <= w(e')$.

  Заменим ребро $e'$ в $T_min$ на ребро $e$. Полученное дерево также является минимальным остовным деревом графа $G$, поскольку все вершины по-прежнему связаны и вес дерева не увеличился.

  Следовательно $E' union {e}$ можно дополнить до минимального остовного дерева $=>$ ребро $e$ -- безопасное.
]

#note("Алгоритм Прима")[
  По сути является реализацией теоремы выше -- выбираем произвольную вершину и обходим весь граф по минимальным рёбрам, которые сейчас доступны.

  Из теоремы следует, что в конце получим минимальное остовное дерево.

  Сложность $O((V + E)log V)$:
  - В куче находится не более $V$ вершин.
  - Извлечём из кучи $V$ вершин.
  - Добавим в неё $E$ вершин.
]

#note("DSU")[
  Хотим структуру данных, которая будет работать с множеством непересекающихся множеств, она будет обрабатывать два типа запросов:
  - $"Unite"(a, b)$ -- объединить два множества, где находятся $a$ и $b$
  - $"AreSame"(a, b)$ -- узнать, лежат ли $a$ и $b$ в одном множестве
  Храним каждое множество, как подвешенное дерево, тогда его представителем (тем, что сравнивается при AreSame, назовём функцию поиска представителя FindSet) будет корень дерева.
  Нам понадобятся две эвристики:
  - Ранговая. При объединении двух множеств подвешивать то, чей ранг меньше к тому, чей ранг больше. Ранг -- глубина дерева.
  - Сжатие путей. При запросе FindSet будем подвешивать все вершины сразу к корню в ходе подъёма по пути.
]

#definition[
  *Функцией Аккермана* на паре целых чисел определим
  #eq[
    $A(m, n) = cases(n + 1\, m = 0, A(m - 1, 1)\, n = 0, A(m - 1\, A(m\, n - 1)))$
  ]
  Нам важно лишь знать, что $A(4, 4) = 2^2^2^2^65536 - 3$
]

#definition[
  Введём *обратную функцию Аккермана*:
  #eq[
    $alpha(N) = min {k | A(k, k) >= N }$
  ]
]

#theorem("Тарьян")[
  При использовании обеих эвристик, время на запрос DSU составляет $O(alpha(N))$
]

#note("Алгоритм Крускала")[
  - Отсортируем рёбра графа по весу
  - Инициализируем DSU на $abs(V)$ множествах, каждое из которых отвечает за компоненту связности, которой принадлежит вершина
  - Берём минимальное ребро, из тех, вершины которого находятся в разных компонентах связности
  - Берём рёбра, пока не останется 1 компонента связности
  Очевидно, сложность $O(E log E)$
]
