#import "../conf.typ": *

== RMQ. Sparse table. Дерево отрезков.

#note("Разреженная таблица")[
  Разреженная таблица -- двумерная структура данных $S T [i][j]$, построенная на бинарной, коммутативной, ассоциативной и идемпотентной операции $F$, для которой
  #eq[
    $S T [i][j] = F(... F(F(A[i], A[i + 1]), ...), ..., A[i + 2^j - 1]); j in [0 ... log N]$
  ]
  Объём памяти, занимаемый таблицей, равен $O(N log N)$, и заполненными являются только те элементы, для которых $i + 2^j <= N$.

  Теперь заметим, что для отрезка $[l, r]$ верно, что
  #eq[
    $F(A[l], ..., A[r]) = F(S T [l][j], S T [r - 2^j + 1][j]), j = floor(log_2(r - l + 1))$
  ]
]

#definition[
  *RMQ или range min query* -- запрос минимума на подотрезке. Решается с помощью Sparse Table с $F = min$ 
]

#note("Дерево отрезков")[
  Дерево отрезков способно за $O(log n)$ получать на подотрезке результат любой операции, которая ассоциативна, коммутативна и имеет нейтральный элемент.

  Опишем нерекурсивной построение дерева на массиве длины $N$. Для удобства будем считать, что $log_2 N in NN$, иначе дозаполним до степени двойки нейтральными элементами.

  Теперь заведём массив длины $2 N - 1$ и будем его заполнять таким образом, что последние $N$ элементов будут элементами исходного массива, а первые $N - 1$ элементов заполним, как $t[i] = F(t[2 i + 1], t[2 i + 2])$.

  Для обновления листа $i >= N / 2$ обновим его самого, а потом будем подниматься по дереву (На каждой итерации делаем $i' = floor(i / 2)$) и пересчитаем все значения, зависимые от изменённого.
]
