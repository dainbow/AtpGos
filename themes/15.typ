#import "../conf.typ": *

== Поиск сильно-связных компонент в графе

#definition[
  Две вершины $u, v in V$ *сильно связаны* в орграфе $G$, если есть путь как из $u$ в $v$, так и наоборот.
]

#definition[
  *Компоненты сильной связности* -- классы эквивалентности по отношению сильной связности.
]

#definition[
  Графом конденсации называют граф, где все компоненты сильной связности сжаты до одной вершины, а рёбра между ними получаются, как рёбра между компонентами.
]

#lemma[
  Пусть $C$ и $C'$ -- две различные вершины в графе конденсации, при этом между ними есть ребро $(C, C')$, тогда $t_"out"[C] > t_"out"[C']$
]

#proof[
  Рассмотрим два случая:
  - Зашли DFS'ом в $C$ раньше, чем в $C'$, значит выйдет алгоритм из $C$ не раньше, чем посетит всю $C'$. Только затем алгоритм вернётся обратно в $C$ и допроходит его.
  - Если же зашли в $C'$ раньше, чем в $C$, то значит мы зайдём в $C$ только после выхода из $C'$ (иначе существовало бы ребро $(C', C)$), а значит и выйдем из $C$ точно позднее $C'$.  
]

#note("Алгоритм Касарайю")[
  Ищет компоненты сильной связности
  - Запускаем DFS на графе, получаем вершины в порядке увеличения времени выхода
  - Строим транспонированный граф
  - Запускаем на транспонированном графе DFS в порядке уменьшения времени выхода в исходном графе. Каждая найденная компонента является компонентой сильной связности.
]

#proof[
  Рассмотрим первый вызов DFS на третьем шаге, так как это вершина с максимальным временем выхода, то нет ребёр в её компоненту связности (по лемме выше).

  При этом в транспонированном графе получаем, что из рассматриваемой компоненты нет рёбер в другие, а значит DFS посетит только саму компоненту.
]
