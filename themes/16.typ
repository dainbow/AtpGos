#import "../conf.typ": *

== Мосты и точки сочленения в графе

#definition[
  *Мост* -- ребро, при удалении которого увеличивается число компонент связности.
]

#note("Поиск мостов")[
  Введём функцию $t_"up" (v)$, определяемую следующим образом:
  #eq[
    $t_"up" (v) = min cases(t_"in" (v), t_"in" (u)\, "где u")$
  ]
  $u$ -- предок $v$ и при этом $u$ достижима по обратному ребру из $w$ -- вершины поддерева $v$.
]

#lemma[
  Ребро $(t, v)$ является мостом тогда и только тогда, когда $t_"up" (v) = t_"in" (v)$
]

#proof[
  Условие равносильно тому, что не найдётся вершины $u$, в которую по обратному ребру можно прыгнуть из поддерева $v$, что то же самое, что суть моста.
]

#definition[
  *Точка сочленения* -- вершина, при удалений которой увеличивается число компонент связности.
]

#note("Поиск точек сочленения")[
  Рассмотрим ребро $(v, w)$, где $v$ не является корнем дерева обхода. Тогда $t_"up" (w) >= t_"in" (v)$ равносильно тому, что $v$ -- точка сочленения.
]

#proof[
  Выполнение этого неравенства означает, что, пытаясь выпрыгнуть из поддерева $w$, мы не можем прыгнуть выше $v$, то есть путь из $u$ в потомках $v$ обязательно пройдёт через неё.

  В обратную сторону. Пусть для всех детей $v$ верно, что $t_"up" (w) < t_"in" (v)$, тогда из каждого ребёнка можно прыгнуть в наддерево, откуда $v$ -- не точка сочленения.
]

