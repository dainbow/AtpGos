#import "../conf.typ": *


== Недетерминированные конечные автоматы, различные варианты определения

#definition[
  *Недетерминированный конечный автомат* -- это пятёрка $M = angles(Q\, Sigma\, Delta\, q_0\, F)$, где $Sigma$ -- конечный алфавит, $Q$ и $Delta$ -- конечные множества, $Delta subset.eq Q times Sigma^* times Q, q_0 in Q, F subset.eq Q$.

  Элементы $Q$ называются *состояниями*, $q_0$ -- стартовое состояние, элементы $F$ -- *заключительными состояниями*.

  Если $angles(p\, x\, q) in Delta$, то этот объект называется *переходом* из $p$ в $q$, а слово $x in Sigma^*$ -- *меткой* этого перехода.
]

#definition[
  $tack_M$ -- наименьшее рефлексивное транзитивное отношение, такое, что
  #eq[
    $angles(q_1\, u) -> q_2 in Delta => angles(q_1\, u w) -> angles(q_2\, w)$
  ]
]

#definition[
  Множество $L(M) = {w in Sigma^* | angles(q_0\, w) tack_M angles(q\, epsilon), q in F}$ -- язык, распознаваемый автоматом $M$.
]

#definition[
  Два конечных автомата эквивалентны, если они распознают один и тот же язык.
]

#lemma[
  Для всякого НКА найдётся эквивалентный НКА с не более чем однобуквенными переходами
]

#proof[
  Разобьём многобуквенные перехода по одной букве
]

#lemma[
  Для всякого НКА найдётся эквивалентный НКА с ровно однобуквенными переходами
]

#proof[
  Строим НКА с $<= 1$ буквенными переходами, а затем трансформируем все пары переходов:
  #eq[
    $angles(q_1\, epsilon) -> q_2, angles(q_2\, a) -> q_3 => angles(q_1\, a) -> q_3$
  ]
  Эквивалентность полученного автомата с исходным доказывается проверкой включений распознаваемых языков в обе стороны.
]
