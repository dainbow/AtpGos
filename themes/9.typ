#import "../conf.typ": *

== LCA. Двоичные подъёмы и сведение к RMQ

#definition[
  Пусть дано дерево $T$, подвешенную за вершину $r$.

  Тогда назовём *наименьшим общим предком (LCA)* двух вершин $u, v$ такую вершину $X = "LCA"(u, v)$, то она лежит на путях $u -> r, v -> r$, при этом такая вершина глубже всех подходящих.
]

#note("Метод двоичных подъёмов")[
  Сделаем предпосчёт двумерной матрицы $d p[v][v]$ -- номер вершины, в которую мы придём, если пройдём из вершины $v$ вверх по дереву $2^i$ шагов.

  Пусть номер родители вершины $v -- p[v]$, её глубина -- $d[v]$, причём если $v$ -- корень, то $p[v] = v$.

  Тогда для $d p$ есть рекуррентная формула:
  #eq[
    $d p [v][i] = cases(p[v]\, i = 0, d p[d p[v][i - 1]][i - 1]\, i > 0)$
  ]
  Заметим, что $i <= log_2 n$, так как иначе мы остаёмся в корне. Значит матрица занимает $O(N log N)$ памяти.

  Пусть $c = "LCA"(v, u), u != v$, тогда по определению $c <= min(d[v], d[u])$. Пусть $d[u] < d[v]$, тогда нам надо подняться вверх на $d[v] - d[u]$ шагов, для этого разобьём данную разность на степени двойки и поднимемся за $O(log N)$.

  Теперь будем считать, что $d[u] = d[v], u != v$. Остаётся тривиальный параллельный подъём до общего предка не более чем на $log_2 N$ вверх.
]

#note("Сведение LCA к RMQ")[
  Заметим, что если $w$ -- LCA вершин $u$ и $v$, то DFS из корня посетит сначала $w$, потом БОО зайдёт в $u$, затем снова посетит $w$ и аналогично с $v$.

  Поэтому нам достаточно знать для каждой вершины время её посещения обходом в глубину и её высоту:
  - Массив Order, где $"Order"[i]$ -- номер вершины, посещённой в момент времени $i$
  - Массив высот $h$, где $h[i]$ -- высота вершины $"Order"[i]$
  - Массив First, где $"First"[v]$ -- момент времени, когда вершина $v$ была посещена впервые

  Тогда для $"LCA"(u, v)$ нужно найти $"Order"[min (h["First"[u] : "First"[v]])]$, задачу поиска минимума на подотрезке как раз поможет решить RMQ.
]
