#import "../conf.typ": *

== Сортировка слиянием. Поразрядные сортировки.

#note("MergeSort")[
  Воспользуемся стратегией разделяй и властвуй:
  - Разбиить массив на две примерно равные половины
  - Разбиваем массивы дальше пополам, пока не дойдём до массива из двух элементов, там всё тривиально
  - Сольём два отсортированных массива в один большой

  Два отсортированных массива сливаются методом двух указателей -- $O(N)$ времени и доппамяти.

  Для подсчёта общего времени работы рассмотрим дерево рекурсии. В нём $log N$ уровней, при этом на каждом уровне после слияния отсортированная часть массива будет увеличиваться примерно в два раза.

  Значит нам потребуется $log N$ слияний -- итоговое время $O(N log N)$. А доппамять линейна.
]

#definition[
  Сортировка называется *стабильной*, если равные элементы относительно компаратора не поменяют своего взаимного расположения после сортировки.
]

#note("Поразрядная сортировка")[
  Рассмотрим сортировку подсчётом, считать будем в массиве $P$:
  - Пройдёмся по исходному массиву и запишем в $P[i]$ число объектов с ключом (по чему сортируем) $i$
  - Посчитаем префиксные суммы массива $P$, тогда мы знаем, начиная с какого индекса в сортированном массиве надо писать структуру с ключом $i$.
  - Идём по изначальному массиву слева направо и вписываем каждый элемент в сортированный массив, согласно префиксным суммам.
  Данная сортировка, очевидно, стабильна, однако при большом количестве разных чисел, расходы на массив подсчёта станут огромными.

  Тогда научимся сортировать числа из большого диапазона! Рассмотрим массив произвольных uint32_t. 
  
  Давайте сортировать данные числа как двоичные строки, сначала сортируем по убыванию последнего байта, потом стабильно по убыванию второго байта etc.
  Работает это за $O(N k)$ времени, где $k$ - это число байтов, то есть константа.
  Массив подсчёта, очевидно, будет небольшим - 256. 
]
