#import "../conf.typ": *

== Двойная куча и сортировка кучей. Слияние $k$ отсортированных массивов с помощью кучи.

#definition[
  Дерево называется *подвешенным*, если у него есть выделенная вершина, называемая *корнем* дерева.
]

#definition[
  Дерево называется *бинарным*, если у каждой вершины степень не более трёх, то есть один родитель и не более двух детей.
]

#definition[
  Бинарное дерево называется *полным*, если все его уровни полностью заполнены.
]

#note("Бинарная пирамида")[
  Хотим такую структуру:
  #eq[
    #table(
      align: center,
      columns: 2,
      [*Операция*], [*Время*],
      [Добавление элемента], [$O(log N)$],
      [Удаление минимума], [$O(log N)$],
      [Чтение минимума], [$O(1)$],
    )
  ]
  Бинарную пирамиду будем реализовывать на полном бинарном дереве, при этом будем поддерживать *свойство пирамиды* -- все сыновья вершины строго больше её самой. 

  Тогда, очевидно, в корне всегда будет минимум, который и будем брать за константу.

  Определим две вспомогательные операции -- просеивание вниз и просеивание вверх. Просеивание вниз старается "утопить" элемент как можно ниже, меняя его местами с меньшим из сыновыей, не нарушая свойство пирамиды.

  Для вставки будем хранить помимо указателя на корень ещё и указатель на самый правый узел, у которого меньше двух сыновый. Тогда подвесим новый элемент к этому узлу и потом просеим его вверх.

  Если же таких узлов нет, то весь нижний уровень занят, а значит подвесим новый элемент к самому левому узлу и также просеим вверх.

  Для удаления поменяем местами корень и крайний узел, а затем просеим вниз элемент в корне, а лист с минимумом просто удалим.
]

#note("HeapSort")[
  Для сортировки массива построим на нём пирамиду и $N$ раз извлечём минимум. Итоговое время $O(N log N)$.
]

#note("Слияние k отсортированных массивов")[
  Обобщение метода двух указателей:
  - Из каждого из $k$ массивов берём по первому элементу, добавляем в кучу
  - Берём из кучи минимальный, он будет следующим элементов слитого массива, добавляем в кучу следующий элемент из исходного массива только что взятого элемента.
  - Повторяем до опустошения всех массивов
  Очевидно, сложность $O(N k log k)$
]
