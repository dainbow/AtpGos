#import "../conf.typ": *

== Динамический массив. Амортизационный анализ. Учётная оценка времени добавления элемента в динамический массив.

#definition[
  Пусть $f, g$ -- произвольные функции, тогда
  #eq[
    $f(x) = O(g(x)) <=> exists M > 0 : exists x_0 : forall x >= x_0 : abs(f(x)) <= M abs(g(x))$
  ]
]

#definition[
  Пусть время $n$ последовательных операций над некоторой структурой данных составит $t_1, ..., t_n$, тогда говорят, что *амортизированная стоимость* или *учётное время* операции составляет $t^* = 1 / n sum_(i = 1)^n t_i$.
]

#note[
  Далее, амортизированная сложность будет обозначаться со звездочкой, например, $O^* (1)$
]

#note("Динамический массив")[
  Интерфейс динамического массива:
  - Обращение по индексу за $O(1)$
  - Добавить элемент в конец за $O^* (1)$
]

#note("Объяснение амортизационной сложности добавления")[
  Очевидно, что при заполнении массива нам нужно делать реаллокацию. (Которая условно бесплатная, но копирование всех элементов на новое место -- линейно).

  Но, оказывается, если при каждой реаллокации мы будем увеличивать массив в два раза, то средняя стоимость добавления элемента в массив будет константной

  Для доказательства будем использовать метод монеток. 
  - Пусть мы только что совершили реаллокацию -- у нас есть $n / 2$ свободного места и столько же уже добавленных элементов
  - Пусть добавляем один из $n / 2$ новых элементов -- пусть его индекс $i >= n / 2$. Тогда, потратив монетку на добавление без реалокации, заложим по одной монетке на будущее копирование $i$-го и $i - n / 2$-элемента.
  - Таким образом, к заполнению буфера из $n$ элементов, мы заложим по монетке за каждый элемент и после новой реалокации сможем условно бесплатно скопировать их на новое место, потратив монетки. 
]

