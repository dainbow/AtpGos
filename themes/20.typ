#import "../conf.typ": *

== Вычисление выпуклой оболочки в 2D

#definition[
  *Выпуклая оболочка* для набора точек на плоскости -- многоугольник минимальной площади, внутри которого (или на его границе) лежат все точки из набора.
]

#note("Алгоритм Джарвиса")[
  - В качестве начальной берётся самая левая нижняя точка $P_1$, она точно является вершиной выпуклой оболочки.
  - Следущей точкой $P_2$ берём такую точку, которая имеет наименьший положительный полярный угол относительно точки $P_1$ как начала координат. После этого для каждой точки $P_i$ против часовой стрелки за $O(n)$ ищется такая точка $P_(i + 1)$ среди оставшихся точек, в которой будет образовывааться наибольший угол между прямыми $P_(i - 1)P_i$ и $P_i P_(i + 1)$. Она и будет следующей вершиной выпуклой оболочки.
  - Нахождение вершин выпуклой оболочки продолжается до тех пор, пока $P_(i + 1) != P_1$
  Работает за $O(N^2)$.
]

#note("Алгоритм Грэхэма")[
  - В качестве начальной берётся самая нижняя (затем самая левая) точка $P_0$, она точно является вершиной выпуклой оболочки.
  - Проводим сортировку точек по углу между векторами $arrow(P_0 P_i), arrow(O X)$. Получим набор $P_1, ..., P_n$
  - Заведём стек точек, добавим в него точки $P_0, P_1$.
  - Будем строить оболочку против часовой стрелки. Тогда будем добавлять в стек точки, пока поворот от вектора $arrow(P_(s - 1) P_s)$ до $arrow(P_s P_k)$ будет левым, где $P_(s - 1), P_s$ -- крайние две точки в стеке, а $P_k$ -- точка из иходного набора, которая ранее не рассматривалась.
  - Если получилось, что рассматриваемый поворот правый, то удалим из стека $P_s$ и проверим тип поворота на новых двух крайних точках стека
  - Пройдя таким образом по всем точкам из набора, в стеке останутся лишь точки, образующие выпуклую оболочку.
  Сложность $O(N log N)$
]
